(defprod doc (empty ())
  (to-list () `(empty))
  (output (indent) ())
  (to-string (indent) ())
  (to-doc () (empty))
  (extent () 0))
(defprod doc (nest ((amount integer) (doc doc)))
  (to-list () `(nest (:amount ,amount :doc ,(synth to-list doc))))
  (output (indent) (synth output doc (+ indent amount)))
  (to-string (indent) (with-output-to-string (*standard-output*)
			(synth output (nest amount doc) indent)))
  (to-doc () (nest amount doc))
  (extent () (+ amount (synth extent doc))))

(defun replace-all (string part replacement &key (test #'char=))
"Returns a new string in which all the occurences of the part 
is replaced with replacement."
    (with-output-to-string (out)
      (loop with part-length = (length part)
            for old-pos = 0 then (+ pos part-length)
            for pos = (search part string
                              :start2 old-pos
                              :test test)
            do (write-string string out
                             :start old-pos
                             :end (or pos (length string)))
            when pos do (write-string replacement out)
            while pos))) 

(defun escape (string)
  (let* ((string1 (replace-all string "&agrave;" "&agrave;" ))
         (string2 (replace-all string1 "&egrave;" "&egrave;" ))
         (string3 (replace-all string2 "ì" "&igrave;" ))
         (string4 (replace-all string3 "&ograve;" "&ograve;" ))
         (string5 (replace-all string4 "ù" "&ugrave;" )))
    string5))

(defprod doc (text ((template string) &rest (args (list doc))))
  (to-list () `(text (:template ,template :args ,args)))
  (output (indent) (format t "~v,0t~?" indent template args))
  (to-string (indent) (escape (with-output-to-string (*standard-output*)
                         (synth output (apply #'text template args) indent))))
  (to-doc () (apply #'text template args))
  (extent () (length (apply #'format nil template args))))

(defprod doc (vcat (&rest (docs (list doc))))
  (to-list () `(vcat (:docs ,(synth-all to-list docs))))
  (output (indent) (let ((fdocs (flatten docs :test #'hash-table-p)))
		     (unless (null fdocs) 
		       (progn (synth output (car fdocs) indent)
			      (unless (null (cdr fdocs)) 
				(progn (format t "~%"))
				(synth output (apply #'vcat (cdr fdocs)) indent))))))
  (to-string (indent) (with-output-to-string (*standard-output*)
			(synth output (apply #'vcat docs) indent)))
  (to-doc () (apply #'vcat docs))  
  (extent () (let ((fdocs (flatten docs :test #'hash-table-p)))
		     (synth extent (car (last fdocs))))))

(defprod doc (hcat (&rest (docs (list doc))))
  (to-list () `(hcat (:docs ,(synth-all to-list docs))))
  (output (indent) (let ((fdocs (flatten docs :test #'hash-table-p)))
		     (unless (null fdocs) 
		     	 (progn (synth output (car fdocs) indent)
		     		(synth output (apply #'hcat (cdr fdocs)) (+ indent (synth extent (car fdocs))))))))
  (to-string (indent) (with-output-to-string (*standard-output*)
			(synth output (apply #'hcat docs) indent)))
  (to-doc () (apply #'hcat docs))
  (extent () (let ((fdocs (flatten docs :test #'hash-table-p)))
	       (reduce #'+ (synth-all extent fdocs)))))
(defun dotted (x)
  (and (consp x)
       (atom (car x))
       (and (atom (cdr x))
	    (not (null (cdr x))))))
(defun assoc-list (x)
  (every #'dotted x))

(defun wrap (doc start end &key newline (padding 0))
  (if newline 
      (vcat start doc end)
      (hcat start (padding padding) doc (padding padding) end)))
(defmacro defwrapper (name start end)
  `(defun ,name (doc &key newline (padding 0))
     (wrap doc (text ,start) (text ,end) :newline newline :padding padding)))

(defmacro vcat-all (fn lst)
  `(apply #'vcat (mapcar #',fn ,lst)))
(defwrapper parens "(" ")")
(defwrapper brackets "[" "]")
(defwrapper braces "{" "}")
(defwrapper single-quotes "'" "'")
(defwrapper double-quotes "\"" "\"")

(defun padding (p)
  (text "~a" (make-string p :initial-element #\Space)))

(defun comma ()
  (text ","))
(defun dot ()
  (text "."))
(defun semi ()
  (text ";"))
(defun forward-slash ()
  (text "/"))
(defun punctuate (p newline &rest docs)
  (cond ((null docs) nil)
	((eq 1 (length docs)) (car docs))
	(t (if newline
	       (vcat (hcat (car docs) p) (apply #'punctuate p newline (cdr docs)))
	       (hcat (car docs) p (apply #'punctuate p newline (cdr docs)))))))

(defun postpend (p newline &rest docs)
  (cond ((null docs) (empty)) 
	((eq 1 (length docs)) (hcat (car docs) p))
        (t (if newline
	       (vcat (hcat (car docs) p) (apply #'postpend p newline (cdr docs)))
	       (hcat (car docs) p (apply #'postpend newline (cdr docs)))))))

(defun prepend (p newline &rest docs)
  (cond ((null docs) (empty)) 
	((eq 1 (length docs)) (hcat p (car docs)))
        (t (if newline
               (vcat (hcat p (car docs)) (apply #'prepend p newline (cdr docs)))
	       (hcat p (car docs) (apply #'prepend newline (cdr docs)))))))


(defun equals () 
  (text "="))
(defun textify (x)
  (text "~a" (lower-camel x)))
(defparameter *doc* (vcat (hcat (text "public static main(")
				(vcat (text "String[] argv,")
				      (text "int a"))
				(text ") {"))
			  (nest 4 (text "print();"))
			  (text "}")))
;; (defparameter *doc* (text "~a~%" 1))
;; (defparameter *doc* (hcat (text "hello")
;; 			  (text "hello ~a" 3)))

;; (synth output *doc* 0)

